#include "../../../nem.hpp"

namespace nem::hacks {
    int c_exploits::compute_type( ) const {
        if ( !valve___g_local_player
            || g_movement->should_fake_duck( ) )
            return 0;

        if ( hacks::g_aim_bot->cfg ( ).m_bDoubleTap )
            return 3;

        if ( hacks::g_aim_bot->cfg ( ).m_bHideShots )
            return 1;

        return 0;
    }

    int get_hitgroups_to_set_ ( )
    {
        if ( !valve___g_local_player || !valve___g_local_player->alive ( ) )
            return 0;

        auto wpn = valve___g_local_player->weapon ( );

        if ( !wpn )
            return 0;

        switch ( wpn->item_index ( ) )
        {
            case valve::e_item_index::awp:
                return hacks::g_aim_bot->cfg ( ).m_iHitboxes_AWP;
            case valve::e_item_index::ssg08:
                return hacks::g_aim_bot->cfg ( ).m_iHitboxes_SSG08;
            case valve::e_item_index::scar20:
            case valve::e_item_index::g3sg1:
                return hacks::g_aim_bot->cfg ( ).m_iHitboxes_Scar;
            case valve::e_item_index::ak47:
            case valve::e_item_index::aug:
            case valve::e_item_index::bizon:
            case valve::e_item_index::famas:
            case valve::e_item_index::galil:
            case valve::e_item_index::m249:
            case valve::e_item_index::m4a1:
            case valve::e_item_index::m4a1_silencer:
            case valve::e_item_index::mac10:
            case valve::e_item_index::mag7:
            case valve::e_item_index::mp5sd:
            case valve::e_item_index::mp7:
            case valve::e_item_index::mp9:
            case valve::e_item_index::negev:
            case valve::e_item_index::nova:
            case valve::e_item_index::sawedoff:
            case valve::e_item_index::sg553:
            case valve::e_item_index::ump45:
            case valve::e_item_index::xm1014:
            case valve::e_item_index::p90:
                return hacks::g_aim_bot->cfg ( ).m_iHitboxes_Rifles;
            case valve::e_item_index::revolver:
            case valve::e_item_index::deagle:
                return hacks::g_aim_bot->cfg ( ).m_iHitboxes_DeagleR8;
            case valve::e_item_index::cz75a:
            case valve::e_item_index::elite:
            case valve::e_item_index::fiveseven:
            case valve::e_item_index::hkp2000:
            case valve::e_item_index::glock:
            case valve::e_item_index::p250:
            case valve::e_item_index::tec9:
            case valve::e_item_index::usp_silencer:
                return hacks::g_aim_bot->cfg ( ).m_iHitboxes_Pistols;
            default:
                return 0;
        }

        return 0;
    }

    int get_multi_points_to_set_ ( )
    {
        if ( !valve___g_local_player || !valve___g_local_player->alive ( ) )
            return 0;

        auto wpn = valve___g_local_player->weapon ( );

        if ( !wpn )
            return 0;

        switch ( wpn->item_index ( ) )
        {
            case valve::e_item_index::awp:
                return hacks::g_aim_bot->cfg ( ).m_iMultipoints_AWP;
            case valve::e_item_index::ssg08:
                return hacks::g_aim_bot->cfg ( ).m_iMultipoints_SSG08;
            case valve::e_item_index::scar20:
            case valve::e_item_index::g3sg1:
                return hacks::g_aim_bot->cfg ( ).m_iMultipoints_Scar;
            case valve::e_item_index::ak47:
            case valve::e_item_index::aug:
            case valve::e_item_index::bizon:
            case valve::e_item_index::famas:
            case valve::e_item_index::galil:
            case valve::e_item_index::m249:
            case valve::e_item_index::m4a1:
            case valve::e_item_index::m4a1_silencer:
            case valve::e_item_index::mac10:
            case valve::e_item_index::mag7:
            case valve::e_item_index::mp5sd:
            case valve::e_item_index::mp7:
            case valve::e_item_index::mp9:
            case valve::e_item_index::negev:
            case valve::e_item_index::nova:
            case valve::e_item_index::sawedoff:
            case valve::e_item_index::sg553:
            case valve::e_item_index::ump45:
            case valve::e_item_index::xm1014:
            case valve::e_item_index::p90:
                return hacks::g_aim_bot->cfg ( ).m_iMultipoints_Rifles;
            case valve::e_item_index::revolver:
            case valve::e_item_index::deagle:
                return hacks::g_aim_bot->cfg ( ).m_iMultipoints_DeagleR8;
            case valve::e_item_index::cz75a:
            case valve::e_item_index::elite:
            case valve::e_item_index::fiveseven:
            case valve::e_item_index::hkp2000:
            case valve::e_item_index::glock:
            case valve::e_item_index::p250:
            case valve::e_item_index::tec9:
            case valve::e_item_index::usp_silencer:
                return hacks::g_aim_bot->cfg ( ).m_iMultipoints_Pistols;
            default:
                return 0;
        }

        return 0;
    }


    void trace_line ( vec3_t& absStart, const vec3_t& absEnd, valve::e_mask mask, valve::c_player* ignore, valve::trace_t* ptr )
    {
        valve::ray_t ray ( absStart, absEnd );
        valve::trace_filter_simple_t filter;
        filter.m_ignore_entity = ignore;

       valve___g_engine_trace->trace_ray ( ray, mask, reinterpret_cast< valve::trace_filter_t* >( &filter ), ptr );
    }

    bool c_exploits::is_peeking ( qangle_t& angle, float ticks ) {
      
        bool player_found = false;

        if ( !valve::g_local_player ||
            !valve::g_local_player->weapon ( ) )
            return false;

        if ( valve::g_local_player->velocity ( ).length_2d ( ) < crypt_float ( 7.f ) )
            return false;

        for ( int i = 1; i <= valve___g_global_vars->m_max_clients; ++i )
        {
            auto entry = hacks::g_lag_comp->entry ( i - 1 );

            if ( !valve::g_local_player || !valve::g_local_player->alive ( ) )
                continue;

            if ( !entry.m_player || !entry.m_player->alive ( )
                || entry.m_player == valve::g_local_player || entry.m_player->dormant ( ) || entry.m_player->friendly ( ) )
                continue;

            if ( entry.m_lag_records.empty ( ) )
                continue;

            auto& lag_record = entry.m_lag_records.back ( );

            if ( !lag_record )
                continue;

            aim_target_t target {};

            target.m_entry = const_cast< player_entry_t* >( &entry );
            target.m_lag_record = lag_record;

            vec3_t next_shot_pos = g_context->shoot_pos ( ) + (valve___g_local_player->velocity ( ) * valve___g_global_vars->m_interval_per_tick ) * ticks;
            g_aim_bot->scan_points ( target, ( 1 << 1 | 1 << 3 | 1 << 4 ), ( 1 << 1 | 1 << 3 | 1 << 4 ), true, next_shot_pos );

            if ( g_aim_bot->select_points ( target, false ) ) {
                player_found = true;
                break;
            }
        }

        return player_found;
    }

    bool c_exploits::is_peeking_one_tick( qangle_t& angle, bool& send_packet ) {

        bool player_found = false;

        if ( !valve::g_local_player ||
            !valve::g_local_player->weapon( ) )
            return false;

        if ( valve::g_local_player->velocity( ).length_2d( ) < crypt_float( 15.f ) )
            return false;

        for ( int i = 1; i <= valve___g_global_vars->m_max_clients; ++i )
        {
            auto entry = hacks::g_lag_comp->entry( i - 1 );

            if ( !valve::g_local_player || !valve::g_local_player->alive( ) )
                continue;

            if ( !entry.m_player || !entry.m_player->alive( )
                || entry.m_player == valve::g_local_player || entry.m_player->dormant( ) || entry.m_player->friendly( ) )
                continue;

            if ( entry.m_lag_records.empty( ) )
                continue;

            auto lag_record = entry.m_lag_records.back( );

            if ( !lag_record )
                continue;

            aim_target_t target{};

            target.m_entry = const_cast< player_entry_t* >( &entry );
            target.m_lag_record = lag_record;
            vec3_t next_shot_pos = g_context->shoot_pos( );
            g_aim_bot->scan_points( target, ( 1 << 1 | 1 << 3 | 1 << 4 ), ( 1 << 1 | 1 << 3 | 1 << 4 ), true, next_shot_pos );

            if ( g_aim_bot->select_points( target, false ) ) {
                player_found = true;
                break;
            }
        }

        return player_found;
    }


	void c_exploits::manage_wpn( valve::user_cmd_t& user_cmd ) {
        m_dt_ready = m_force_choke = false;

        const auto weapon = valve___g_local_player->weapon( );
        const auto wpn_data = weapon ? weapon->wpn_data( ) : nullptr;

        int shift_amount{};

        if ( ( m_type = compute_type( ) ) ) {
            if ( weapon ) {
                const auto item_index = weapon->item_index( );
                if ( item_index != valve::e_item_index::taser
                    && item_index != valve::e_item_index::c4
                    && wpn_data && wpn_data->m_unk_type != 1
                    && !( item_index >= valve::e_item_index::flashbang && item_index <= valve::e_item_index::inc_grenade ) ) {
                    if ( m_ticks_allowed ) {
                        if ( m_type == 1 )
                            shift_amount = 8;
                        else if ( m_type == 2 || m_type == 3 ) {
                            if ( g_context->can_shoot( weapon, user_cmd, false, m_ticks_allowed, false ) )
                                shift_amount = m_ticks_allowed;
                        }

                        if ( valve___g_global_vars->m_cur_time >= valve___g_local_player->next_attack( ) ) {
                            m_dt_ready = true;
                            m_force_choke = false;
                            m_next_shift_amount = shift_amount;
                        }

                        goto SKIP;
                    }
                }
            }
        };

        shift_amount = m_cur_shift_amount = m_next_shift_amount = 0;
        if ( !m_type
            && m_ticks_allowed > 0 ) {
            m_type = 4;
            m_cur_shift_amount = m_next_shift_amount = m_ticks_allowed;

            m_charged = true;
        }

    SKIP:
        if ( weapon
            && hacks::g_aim_bot->cfg ( ).m_bEnableRagebot
            && weapon->item_index( ) == valve::e_item_index::revolver ) {
            g_eng_pred->r8_can_shoot( ) = true;

            user_cmd.m_buttons &= ~valve::e_buttons::in_attack2;

            if ( g_context->can_shoot( weapon, user_cmd, true, 0, true ) ) {
                if ( valve___g_global_vars->m_cur_time < g_eng_pred->postpone_fire_ready_time( ) )
                    user_cmd.m_buttons |= valve::e_buttons::in_attack;
                else if ( valve___g_global_vars->m_cur_time < weapon->next_secondary_attack( ) )
                    user_cmd.m_buttons |= valve::e_buttons::in_attack2;
                else
                    g_eng_pred->postpone_fire_ready_time( ) = valve___g_global_vars->m_cur_time + crypt_float ( 0.234375f );

                g_eng_pred->r8_can_shoot( ) = valve___g_global_vars->m_cur_time > g_eng_pred->postpone_fire_ready_time( );
            }
            else {
                user_cmd.m_buttons &= ~valve::e_buttons::in_attack;

                g_eng_pred->postpone_fire_ready_time( ) = valve___g_global_vars->m_cur_time + crypt_float ( 0.234375f );

                g_eng_pred->r8_can_shoot( ) = false;
            }
        }

        if ( ( m_charged || m_shift )
            && ( user_cmd.m_buttons & valve::e_buttons::in_attack ) )
            user_cmd.m_buttons &= ~valve::e_buttons::in_attack;

        g_context->flags( ) &= ~e_context_flags::recharge;

        if ( g_anim_sync->local_data( ).m_shot_valid_wpn
            && g_anim_sync->local_data( ).m_shot_cmd_number > valve___g_client_state->m_last_cmd_out
            && g_anim_sync->local_data( ).m_shot_cmd_number < ( valve___g_client_state->m_last_cmd_out + crypt_int ( 100 ) ) )
            g_context->flags( ) |= e_context_flags::recharge;

        g_context->flags( ) &= static_cast< e_context_flags >( ~0x32u );

        int max_packets = crypt_int ( 14 );

        if ( m_charged )
            g_context->flags( ) &= ~e_context_flags::can_choke;
        else if ( !m_shift ) {
            if ( m_type
                && m_ticks_allowed ) {
                if ( valve___g_client_state->m_net_channel->m_choked_packets >= 1 )
                    g_context->flags( ) &= ~e_context_flags::can_choke;
                else
                    g_context->flags( ) |= e_context_flags::can_choke;
            }
            else {
                if ( valve___g_client_state->m_net_channel->m_choked_packets >= max_packets )
                    g_context->flags( ) &= ~e_context_flags::can_choke;
                else
                    g_context->flags( ) |= e_context_flags::can_choke;
            }
        }
        else
            g_context->flags( ) |= e_context_flags::can_choke | e_context_flags::choke;

        if ( ( !m_force_choke || g_context->flags( ) & e_context_flags::can_choke )
            && g_context->can_shoot( weapon, user_cmd, g_eng_pred->r8_can_shoot( ), shift_amount, false ) )
            g_context->flags( ) |= e_context_flags::can_shoot;
        else
            g_context->flags( ) &= ~e_context_flags::can_shoot;

        if ( g_eng_pred->last_user_cmd( ).m_buttons & valve::e_buttons::in_attack ) {
            if ( weapon 
                && wpn_data
                && wpn_data->m_unk_type == 2 ) {
                if ( weapon->item_index( ) != valve::e_item_index::revolver )
                    g_context->flags( ) &= ~e_context_flags::can_shoot;
            }
        }
	}

    void c_exploits::skip_lag_interpolation ( bool process )
    {
        if ( !valve::g_local_player || !valve::g_local_player->alive ( ) )
            return;

        if ( m_recharge_cmd != valve___g_client_state->m_last_cmd_out )
            return;

        if ( !process )
        {
            m_prediction_tick = valve::g_local_player->final_predicted_tick ( );

            valve::g_local_player->final_predicted_tick ( ) = valve___g_global_vars->m_tick_count + valve::to_ticks ( valve___g_engine->net_channel_info ( )->latency ( 0 ) + valve___g_engine->net_channel_info ( )->latency ( 1 ) );
            return;
        }

        valve::g_local_player->final_predicted_tick ( ) = m_prediction_tick;
    }

    bool c_exploits::try_to_recharge( ) {
        if ( ( valve___g_global_vars->m_cur_time - valve___g_local_player->spawn_time( ) ) < crypt_float ( 1.f ) )
            return false;

        if ( g_movement->stop_type ( ) 
            || g_context->get_auto_peek_info ( ).m_old_shot )
            return false;

        if ( m_recharge_cmd != valve___g_client_state->m_last_cmd_out
            && ( valve___g_client_state->m_choked_cmds || m_ticks_allowed >= 14 ) )
            return false;

        if ( !compute_type( )
            || std::abs( g_anim_sync->local_data( ).m_last_shot_time - valve___g_global_vars->m_cur_time ) < crypt_float ( 0.26f ) )
            return false;

        if ( m_ticks_allowed >= crypt_int ( 14 ) ) {
            m_charged = true;

            if ( ( m_ticks_allowed + 1 ) <= crypt_int ( 16 ) ) {
                if ( m_ticks_allowed < 0 )
                    m_ticks_allowed = 0;
            }
            else
                m_ticks_allowed = crypt_int ( 14 );
            
            return false;
        }

        m_recharge_cmd = valve___g_client_state->m_last_cmd_out;
        
        if ( ++m_ticks_allowed > crypt_int ( 16 ) )
            m_ticks_allowed = crypt_int ( 16 );

		return true;
	}

    int c_exploits::calc_correction_ticks( ) const {
        return valve___g_global_vars->m_max_clients <= 1 
            ? -1 : valve::to_ticks( std::clamp( g_context->cvars( ).m_sv_clockcorrection_msecs->get_float( ) / 1000.f, 0.f, 1.f ) );
    }

    int c_exploits::adjust_tick_base(
        const int old_new_cmds,
        const int total_new_cmds, const int delta
    ) const {
        auto ret = -1;

        const auto correction_ticks = calc_correction_ticks( );
        if ( correction_ticks != -1 ) {
            const auto& prev_local_data = g_eng_pred->local_data( ).at( valve___g_client_state->m_last_cmd_out % 150 );
            if ( prev_local_data.m_spawn_time == valve___g_local_player->spawn_time( ) ) {
                ret = prev_local_data.m_tick_base + 1;

                const auto tick_count = ret + old_new_cmds - m_correction_amount;

                const auto ideal_final_tick = tick_count + correction_ticks;

                const auto too_fast_limit = ideal_final_tick + correction_ticks;
                const auto too_slow_limit = ideal_final_tick - correction_ticks;

                const auto adjusted_final_tick = ret + total_new_cmds;

                if ( adjusted_final_tick > too_fast_limit
                    || adjusted_final_tick < too_slow_limit ) {
                    ret = ideal_final_tick - total_new_cmds;
                }
            }
        }

        if ( ret != -1 )
            return ret;

        const auto& local_data = g_eng_pred->local_data( ).at( ( valve___g_client_state->m_last_cmd_out + 1 ) % 150 );

        return ( local_data.m_spawn_time == valve___g_local_player->spawn_time( )
            ? local_data.m_tick_base : valve___g_local_player->tick_base( ) ) - delta;
    }

    void c_exploits::handle_break_lc(
        const std::uintptr_t ecx, const std::uintptr_t edx, const int slot,
        cc_def ( valve::bf_write_t* ) buffer, int& from, int& to, valve::move_msg_t* move_msg
    ) {
        auto shift_amount = m_cur_shift_amount;

        m_cur_shift_amount = 0;

        const auto v86 = std::min( move_msg->m_new_cmds + m_ticks_allowed, 16 );

        int v69{};

        const auto v70 = v86 - move_msg->m_new_cmds;
        if ( v70 >= 0 )
            v69 = v70;

        m_ticks_allowed = v69;

        const auto old_new_cmds = move_msg->m_new_cmds;

        move_msg->m_new_cmds = std::clamp( move_msg->m_new_cmds + shift_amount, crypt_int ( 1 ), crypt_int ( 62 ) );
        move_msg->m_backup_cmds = 0;

        const auto next_cmd_number = valve___g_client_state->m_last_cmd_out + valve___g_client_state->m_choked_cmds + 1;

        for ( to = next_cmd_number - old_new_cmds + 1; to <= next_cmd_number; ++to ) {
            if ( !hooks::orig_write_user_cmd_delta_to_buffer( ecx, edx, slot, buffer.get ( ), from, to, true ) )
                return;

            from = to;
        }

        for ( auto i = valve___g_client_state->m_last_cmd_out + 1; i <= next_cmd_number; ++i )
            hacks::g_eng_pred->local_data( ).at( i % 150 ).m_shift_amount = shift_amount;

        const auto user_cmd = valve___g_input->user_cmd( slot, from );
        if ( !user_cmd )
            return;

        auto from_user_cmd = *user_cmd, to_user_cmd = *user_cmd;

        if ( shift_amount ) {
            ++to_user_cmd.m_number;

            to_user_cmd.m_tick = std::numeric_limits< int >::max( );

            do {
                buffer.get ( )->write_user_cmd ( &to_user_cmd, &from_user_cmd );

                from_user_cmd = to_user_cmd;

                ++to_user_cmd.m_number;

                --shift_amount;
            } while ( shift_amount );
        }
    }
    __forceinline bool is_zero_vec3_t(vec3_t vec)
    {
        return (vec.x > -0.01f && vec.x < 0.01f &&
            vec.y > -0.01f && vec.y < 0.01f &&
            vec.z > -0.01f && vec.z < 0.01f);
    }

    template<typename T>
    void limit_val ( T& value, const T& min, const T& max )
    {
        if ( value > max )
            value = max;
        else if ( value < min )
            value = min;
    }

    void __forceinline ang_norm ( float& angle )
    {
        angle = fmodf ( angle, 360.0f );

        if ( angle > 180.0f )
            angle -= 360.0f;
        else if ( angle < -180.0f )
            angle += 360.0f;
    }

    __forceinline void norm ( qangle_t& qangle )
    {
        ang_norm ( qangle.x );
        ang_norm ( qangle.y );
        qangle.z = 0.f;
    }


    __forceinline void clamp ( qangle_t& ang )
    {
        norm ( ang );

        ang.x = remainderf ( ang.x, 360.0f ); limit_val ( ang.x, -89.0f, 89.0f );
        ang.y = remainderf ( ang.y, 360.0f ); limit_val ( ang.y, -180.0f, 180.0f );

        ang.z = 0.f;
    }

    void c_exploits::process_real_cmds (
        const std::uintptr_t ecx, const std::uintptr_t edx, const int slot,
        cc_def ( valve::bf_write_t* ) buffer, int& from, int& to, cc_def ( valve::move_msg_t* ) move_msg
    ) {
        auto shift_amount = m_cur_shift_amount;

        m_cur_shift_amount = 0;

        const auto write_real_cmds = m_type == 3 || m_type == 4;

        const auto v86 = std::min( move_msg.get ( )->m_new_cmds + m_ticks_allowed, crypt_int ( 16 ) );

        int v69{};

        auto v70 = v86 - move_msg.get ( )->m_new_cmds;
        if ( write_real_cmds )
            v70 -= shift_amount;

        if ( v70 >= crypt_int ( 0 ) )
            v69 = v70;

        m_ticks_allowed = v69;

        const auto old_new_cmds = move_msg.get ( )->m_new_cmds;

        move_msg.get ( )->m_new_cmds = std::clamp( move_msg.get ( )->m_new_cmds + shift_amount, 1, crypt_int ( 62 ) );
        move_msg.get ( )->m_backup_cmds = 0;

        auto first_tick_base = adjust_tick_base( old_new_cmds, move_msg.get ( )->m_new_cmds, shift_amount );

        if ( m_type == 4 )
            ++first_tick_base;

        const auto next_cmd_number = valve___g_client_state->m_last_cmd_out + valve___g_client_state->m_choked_cmds + 1;

        for ( to = next_cmd_number - old_new_cmds + 1; to <= next_cmd_number; ++to ) {
            if ( !hooks::orig_write_user_cmd_delta_to_buffer( ecx, edx, slot, buffer.get ( ), from, to, true ) )
                return;
                
            from = to;
        }

        for ( auto i = valve___g_client_state->m_last_cmd_out + 1; i <= next_cmd_number; ++i ) {
            auto& local_data = hacks::g_eng_pred->local_data( ).at( i % 150 );

            local_data.m_shift_amount = write_real_cmds ? 0 : shift_amount;
            local_data.m_override_tick_base = true;
            local_data.m_restore_tick_base = write_real_cmds ? local_data.m_restore_tick_base : true;
            local_data.m_adjusted_tick_base = first_tick_base++;
        }

        const auto user_cmd = valve___g_input->user_cmd( slot, from );
        if ( !user_cmd )
            return;

        auto from_user_cmd = *user_cmd, to_user_cmd = *user_cmd;

        ++to_user_cmd.m_number;

        valve___g_prediction->m_prev_start_frame = -1;
        valve___g_prediction->m_cmds_predicted = 0;

        vec2_t target_move{};
        
        qangle_t view_angles {};

        view_angles = valve___g_engine->view_angles ( );

        m_shifting = true;

        if ( write_real_cmds ) {
            ++valve___g_client_state->m_choked_cmds;
            ++valve___g_client_state->m_net_channel->m_choked_packets;
            ++valve___g_client_state->m_net_channel->m_out_seq_number;

            if ( m_type != 4 ) {
                const auto& local_data = hacks::g_eng_pred->local_data( ).at( next_cmd_number % crypt_int ( 150 ) );

                target_move = { local_data.m_move.x, local_data.m_move.y };    
            }

            int shifted_cmds{};

            do {
                valve___g_prediction->update(
                    valve___g_client_state->m_delta_tick,
                    valve___g_client_state->m_delta_tick > 0,
                    valve___g_client_state->m_last_cmd_ack,
                    valve___g_client_state->m_last_cmd_out + valve___g_client_state->m_choked_cmds
                );

                to_user_cmd.m_buttons &= static_cast< valve::e_buttons >( ~4290707449u );
                to_user_cmd.m_move = {};

                if ( valve___g_local_player->alive( ) ) {
                    if ( m_type != 4
                        && !( to_user_cmd.m_buttons & valve::e_buttons::in_jump )
                        && valve___g_local_player->flags( ) & valve::e_ent_flags::on_ground ) {
                        int v17{};
                        if ( ( shift_amount - crypt_int ( 2 ) ) >= 0 )
                            v17 = shift_amount - crypt_int ( 2 ); 
                      
                        if ( shifted_cmds >= v17 ) {
                            hacks::g_movement->stop_type( ) = 2;
                            hacks::g_movement->stop( to_user_cmd );
                        }
                        else {
                            to_user_cmd.m_move.x = target_move.x;
                            to_user_cmd.m_move.y = target_move.y;
                        }
                    }

                    if ( !is_zero_vec3_t( g_context->get_auto_peek_info( ).m_start_pos ) && m_type == 3 )
                    {
                        auto angle = math::calc_ang( valve___g_local_player->abs_origin( ), g_context->get_auto_peek_info( ).m_start_pos );
                        to_user_cmd.m_view_angles.y = angle.y;

                        to_user_cmd.m_move.x = crypt_float( 450.f );
                        to_user_cmd.m_move.y = crypt_float( 0.0f );
                    }
                }

                valve___g_input->m_cmds[ to_user_cmd.m_number % crypt_int ( 150 ) ] = to_user_cmd;
                valve___g_input->m_verified_cmds[ to_user_cmd.m_number % crypt_int( 150 ) ] = { to_user_cmd, to_user_cmd.calc_checksum( ) };

                buffer.get ( )->write_user_cmd ( &to_user_cmd, &from_user_cmd );

                auto& local_data = hacks::g_eng_pred->local_data( ).at( to_user_cmd.m_number % crypt_int ( 150 ) );

                local_data.m_override_tick_base = true;
                local_data.m_adjusted_tick_base = first_tick_base++;

                ++shifted_cmds;

                if ( shifted_cmds >= shift_amount )
                {
                    if ( to_user_cmd.m_tick != std::numeric_limits < float >::max( ) ) {
                        auto& out = g_context->get_out_cmds( ).emplace_back( );
                        out.m_is_outgoing = g_context->send_packet ( );
                        out.m_is_used = false;
                        out.m_command_nr = valve___g_client_state->m_last_cmd_out + valve___g_client_state->m_choked_cmds + crypt_int ( 1 );

                        g_context->add_packet( valve___g_client_state->m_last_cmd_out + valve___g_client_state->m_choked_cmds + crypt_int ( 1 ) );
                    }
                }
                else {
                    ++valve___g_client_state->m_choked_cmds;
                    ++valve___g_client_state->m_net_channel->m_choked_packets;
                    ++valve___g_client_state->m_net_channel->m_out_seq_number;
                }

                from_user_cmd = to_user_cmd;

                ++to_user_cmd.m_number;
            } while ( shifted_cmds < shift_amount );

            m_shifting = false;
        }
        else {
            to_user_cmd.m_tick = std::numeric_limits< int >::max( );

            do {
                buffer.get ( )->write_user_cmd ( &to_user_cmd, &from_user_cmd );

                from_user_cmd = to_user_cmd;

                ++to_user_cmd.m_number;

                --shift_amount;
            } while ( shift_amount );
        }
    }
}