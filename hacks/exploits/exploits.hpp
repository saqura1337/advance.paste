#pragma once

namespace nem::hacks {
	class c_exploits {
	private:
		int compute_type( ) const;

		bool					m_charged{}, m_shift{}, m_shifting {},
								m_force_choke{}, m_dt_ready{};
		int						m_ticks_allowed{}, m_cur_shift_amount{},
								m_next_shift_amount{}, m_recharge_cmd{}, m_type{}, m_correction_amount{}, m_prediction_tick {};
	public:
		void manage_wpn( valve::user_cmd_t& user_cmd );

		bool try_to_recharge( );

		bool is_peeking ( qangle_t& angle, float ticks = 6.f );
		bool is_peeking_one_tick( qangle_t& angle, bool& send_packet );

		int calc_correction_ticks( ) const;

		int adjust_tick_base(
			const int old_new_cmds,
			const int total_new_cmds, const int delta
		) const;

		void handle_break_lc(
			const std::uintptr_t ecx, const std::uintptr_t edx, const int slot,
			cc_def ( valve::bf_write_t* ) buffer, int& from, int& to, valve::move_msg_t* move_msg
		);

		void process_real_cmds (
			const std::uintptr_t ecx, const std::uintptr_t edx, const int slot,
			cc_def ( valve::bf_write_t* ) buffer, int& from, int& to, cc_def ( valve::move_msg_t* ) move_msg
		);

		void skip_lag_interpolation ( bool status );

		__forceinline int& ticks_allowed( );

		__forceinline int& recharge_cmd( );

		__forceinline int& type( );

		__forceinline bool& charged( );

		__forceinline bool& shift( );

		__forceinline bool& is_shifting( );

		__forceinline int& cur_shift_amount( );

		__forceinline int& next_shift_amount( );

		__forceinline int& correction_amount( );

		__forceinline bool& force_choke( );

		__forceinline bool& dt_ready( );
	};

	inline const auto g_exploits = std::make_unique< c_exploits >( );
}

#include "impl/exploits.inl"